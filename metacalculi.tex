\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% PAGE DIMENSIONS
\usepackage{geometry} % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper} % or letterpaper (US) or a5paper or....

\usepackage{graphicx} % support the \includegraphics command and options

%%% FONTS
\usepackage[T1]{fontenc}

%%% PACKAGES
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{multirow}
\usepackage{stackengine}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true, %Colours links instead of ugly boxes
    urlcolor = blue!70!black, %Colour for external hyperlinks
    linkcolor = green!50!black, %Colour of internal links
    citecolor = blue!50!black %Colour of citations
  }
\usepackage[inline]{enumitem}
\usepackage{float}
  \floatstyle{boxed}
  \restylefloat{figure}
\usepackage{subcaption}
\usepackage[noabbrev]{cleveref}
\usepackage{qtree}
\usepackage{tikz}

\newcommand\ldisplaycell[1]{\begin{array}[c]{@{}l@{}}\displaystyle {#1}\end{array}}
\newcommand\ltextcell[1]{\begin{array}[c]{@{}l@{}}\textstyle {#1}\end{array}}

\usepackage{amsthm}
  \theoremstyle{definition}
  \newtheorem{definition}{Definition}
  \theoremstyle{remark}
  \newtheorem{example}{Example}

\usepackage[backend=biber]{biblatex}
  \addbibresource{notation.bib}

\usepackage{mdframed}
\newenvironment{aside}
  {\begin{mdframed}[style=0,%
      leftline=false,rightline=false,leftmargin=2em,rightmargin=2em,%
          innerleftmargin=0pt,innerrightmargin=0pt,linewidth=0.75pt,%
      skipabove=7pt,skipbelow=7pt]\small}
  {\end{mdframed}}

\title{Metacalculi}
\author{Marseille Valen Bouchard Demko}

\begin{document}

\maketitle

\begin{abstract}
We present several formal systems based on the lambda calculus which are capable of some form of metaprogramming.
Exactly what counds as metaprogramming is left informal, but should include Lisp and Scheme macros, as well as Meta-ML and Template Haskell.
\end{abstract}

\section{Splice-Quote Lambda Calculus}

We first recall the applied lambda calculus:

\begin{definition}
A \emph{applied lambda calculus} ($\lambda\delta$) is a formal system.
\begin{enumerate}
\item It is parameterized by
  \begin{enumerate}
    \item a countable set of constants $\mathcal{C}$, and
    \item a countably infinite set of variables $\mathcal{X}$, and
    \item a partial function $\delta : \mathcal C \times \{n : \mathbb N\} \times \mathcal C^n \to \mathcal C$.
  \end{enumerate}
\item Its syntax is:
  \begin{center}
  \begin{tabular}{rcl}
  $c$ & $\in$ & $\mathcal C$ \\
  $x$ & $\in$ & $\mathcal X$ \\
  $e$ & $::=$ & $c$ \\
    & $\mid$ & $x$ \\
    & $\mid$ & $\lambda x.\, e$ \\
    & $\mid$ & $f\;e$ \\
  \end{tabular}
  \end{center}
\item It is equipped with a reduction relation:
  \begin{center}
  \begin{tabular}{rcll}
  $(\lambda x.\, e)\;e'$ & $\longrightarrow$ & $e[x \mapsto e']$ \\
  $\lambda x.\, e\;x$ & $\longrightarrow$ & $e$ & where $x \notin \mathrm{fv}(e)$ \\
  $c\;c_1\;\ldots\;c_n$ & $\longrightarrow$ & $\delta(c, c_1, \ldots, c_n)$ \\
  \end{tabular}
  \end{center}
\item
  The reflexive, transitive, symmetric, compatible closure of the reduction relation is the congruence relation
    $$t \cong t'$$
\end{enumerate}
\end{definition}

The applied lambda calculus can be extended to form the quote-splice calculus.
To do so, we first define s-expressions.

\begin{definition}
Let $\mathcal A$ be a set of \emph{atoms}
An \emph{s-expression} is a datum generated by the grammar:
\begin{center}
\begin{tabular}{rcl}
$a$ & $\in$ & $\mathcal A$ \\
$s$ & $::=$ & $a$ \\
  & $\mid$ & $(s_1\;\ldots\;s_n)$ \\
\end{tabular}
\end{center}
\end{definition}

We then set up appropriate injections between s-expressions and the syntax of our calculus.

\begin{definition}
There is an injection $\lceil \cdot \rfloor : \mathrm{sexpr} \to \mathrm{expr}$:
\begin{enumerate}
\item $\forall a \in \mathcal A.\, \exists c \in \mathcal C.
  \lceil a \rfloor = c$
\item $\forall n \in \mathbb N.\, \exists c \in \mathcal C.
  \lceil (s_1 \ldots s_n) \rfloor = c\;\lceil s_1 \rfloor\;\ldots\;\lceil s_n \rfloor$
\item $\lceil s \rfloor = \lceil s' \rfloor$ only when $s = s'$
\end{enumerate}
\end{definition}

\begin{definition}
Specify a set of representable constants $\mathcal C' \subseteq \mathcal C$ (e.g. numeric literals).
There is an injection $\mathcal S : \mathcal X \cup \mathcal C' \to \mathrm{sexpr}$:
\begin{enumerate}
\item $\forall x \in \mathcal X.\, \exists s.\,
  \mathcal S(x) = s$
\item $\forall x \in \mathcal C'.\, \exists s.\,
  \mathcal S(c) = s$
\item $\mathcal S(p) = \mathcal S(q)$ only when $p = q$
\end{enumerate}
\end{definition}

We then need to extend the syntax and reduction system to cover splices:
\begin{definition}
The \emph{Quote-Splice Lambda Calculus} is an extension of $\lambda\delta$ where:
\begin{enumerate}
\item we extend the syntax with splices
  \begin{center}
  \begin{tabular}{rcl}
  $e$ & $::=$ & $\ldots$ \\
    & $\mid$ & $\$e$ \\
  \end{tabular}
  \end{center}
\item and add a reduction rule showing that quote and splice are dual introduction/eliminatino forms:
  \begin{center}
  \begin{tabular}{rcll}
  $\$\lceil s \rfloor$ & $\longrightarrow$ & $\llbracket s \rrbracket$ \\
  $\lambda x.\, e\;x$ & $\longrightarrow$ & $e$ & where $x \notin \mathrm{fv}(e)$ \\
  $c\;c_1\;\ldots\;c_n$ & $\longrightarrow$ & $\delta(c, c_1, \ldots, c_n)$ \\
  \end{tabular}
  \end{center}
\item where the \emph{parsing} function $\llbracket \cdot \rrbracket : sexpr \nrightarrow expr$.
  To enable parsing, we will need to have $\{\mathtt{lambda}, \mathtt{quote}, \mathtt{eval}\} \subseteq \mathcal A$.
  The parsing function is defined as the smallest (partial) function including the following:
  \begin{enumerate}
    \item $\llbracket \mathcal S(c) \rrbracket = c$
    \item $\llbracket \mathcal S(x) \rrbracket = x$
    \item $\llbracket (\mathtt{lambda}\;s_x\;s) \rrbracket =
      \lambda x.\, \llbracket s \rrbracket$
      where $s_x = \mathcal S(x)$
    \item $\llbracket (s_1\;\ldots\;s_n) \rrbracket =
      \llbracket s_1 \rrbracket\;\ldots\; \llbracket s_n \rrbracket$
      where $s_1 \notin \{\mathtt{lambda}, \mathtt{quote}, \mathtt{eval}\}$
    \item $\llbracket (\mathtt{quote}\;s) \rrbracket = \lceil s \rfloor$
    \item $\llbracket (\mathtt{eval}\;s) \rrbracket = \$\llbracket s \rrbracket$
  \end{enumerate}
\end{enumerate}
\end{definition}

The parsing function is so-called because it represents the extraction of a term of the calculus from some other data structure.
Most commonly, parsing operates over character strings, but in this case,
  it operates on more structured s-expressions.

As a small example, let's implement a simple \texttt{let} syntax.
Let $\mathbf c_i$ be the constant for constructing a size-$n$ combination.
  $$let \triangleq \lambda x,v,e.\, \mathbf c_2\;(\mathbf c_3\;\mathtt{lambda}\;x\;e)\;v$$
To use this definition, it will be convenient to define a little syntactic sugar:
  $$\$e(s_1\;\ldots\;s_n) \equiv \$(e\;\lceil s_1 \rfloor\;\ldots\;\lceil s_n \rfloor)$$
Then we can see that:
\begin{align*}
  \$let(\mathtt x\;2\;(\mathtt{add}\;\mathtt x\;\mathtt x))
    &= \$((\lambda x,v,e.\, \mathbf c_2\;(\mathbf c_3\;\mathtt{lambda}\;x\;e)\;v)\;
        \lceil \mathtt x \rfloor\;\lceil 2 \rfloor\;\lceil (\mathtt{add}\;\mathtt x\;\mathtt x) \rfloor) \\
    % &= \$(\mathbf c_2\;(\mathbf c_3\;\mathtt{lambda}\;\lceil \mathtt x \rfloor\;\lceil(\mathtt{add}\;\mathtt x\;\mathtt x)\rfloor)\;\lceil 2 \rfloor) \\
    % &= \$(\mathbf c_2\;\lceil(\mathtt{lambda}\;\mathtt x\;(\mathtt{add}\;\mathtt x\;\mathtt x))\rfloor\;\lceil 2 \rfloor) \\
    &= \$\lceil(\mathtt{lambda}\;\mathtt x\;(\mathtt{add}\;\mathtt x\;\mathtt x))\;2)\rfloor \\
    &= \llbracket(\mathtt{lambda}\;\mathtt x\;(\mathtt{add}\;\mathtt x\;\mathtt x))\;2)\rrbracket \\
    % &= \llbracket(\mathtt{lambda}\;\mathtt x\;(\mathtt{add}\;\mathtt x\;\mathtt x))\rrbracket\;\llbracket 2 \rrbracket \\
    % &= (\lambda x.\, \llbracket(\mathtt{add}\;\mathtt x\;\mathtt x)\rrbracket)\;2 \\
    % &= (\lambda x.\, \llbracket\mathtt{add}\rrbracket\;\llbracket\mathtt x\rrbracket\;\llbracket\mathtt x\rrbracket)\;2 \\
    &= (\lambda x.\, \mathrm{add}\;x\;x)\;2 \\
    &= \mathrm{add}\;2\;2 \\
    &= 4 \\
\end{align*}

This is nearly the core of Lisp.
Minor differences are that Lisp uses conses instead of lists,
  passes all arguments to a fucntion as a list,
  and pattern-matches the input list agains a simple parameter pattern.
More difficult is that Lisp has \texttt{gensym}, which can produce a fresh symbol.
Finally, and most different, is that Lisp need not explicitly splice:
  it instead recognizes macros and automatically treats them as a splice with the macro parameters filled in with the other s-exprs in the combination.
Exactly how this detection of macros is done is not entirely clear to me yet.

\end{document}
